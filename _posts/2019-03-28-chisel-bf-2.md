---
layout: post
title: "ChiselでBF処理系を作る(2)"
date: 2019-03-28
description: 'チャタリング除去回路の実装'
main-class: 'jekyll'
image: 
color: '#B31917'
tags:
- scala
- FPGA
- Chisel
- Brainf**k
categories:
---

[前回は](https://kamiyaowl.github.io/blog/chisel-bf-1/)BF処理系の説明と全体構成について解説した。次からはいよいよ実装を行う。


<div class="mermaid">
graph LR
    PC -- USB --- USB_Uart
    USB_Uart --Tx--> UartTxRx
    UartTxRx--Rx--> USB_Uart
    UartTxRx -- program/stdin -->FIFO_din
    FIFO_din -- program --> BF_Processor
    FIFO_din -- stdin--> BF_Processor
    BF_Processor -- stdout --> FIFO_dout
    FIFO_dout -- stdout --> UartTxRx
    External_SW --program/run -->UntiChatter
    UntiChatter -->BF_Processor
    style UntiChatter fill:#f66,stroke:#f33
</div>


今回は赤で示すUntiChatterモジュールを実装する。


## チャタリング

プッシュスイッチ、スライドスイッチなどは機械入力を電気信号に変換するが実際の信号ではOff->Onとはキレイに遷移してくれない。具体的にはOn/Offを短期間内で繰り返すような波形となる。

<script type="WaveDrom">
{signal: [
  {name: 'slow_clk', wave: 'P............'},
  {name: 'button_in', wave: '0............................001100101.....................................................................', period: 0.1, phase: 1},
  {name: 'dout', wave: '0.........1..'},
]}
</script>

波形で書くとbutton_inのようになっているため、後の回路が誤動作してしまうことは避けたい。目標としてはdoutのような応答を作りたい。

## 対策

チャタリング防止で調べるといろいろ出てくるが、ボタン入力の高周波成分を取り除ければよいのである。主には以下のあたりが主流だと思う。

1. 回路上にローパスフィルタを挿入
2. ボタン入力を（FPGA上で）ローパスフィルタを通して出力
3. ボタン入力をキャプチャする周波数を下げる

今回は2を採用するが、以下の点から2.3.併用とする。
(先の図ではslow_clkで書いてしまったが)ボタン入力に100MHzほどスピードを上げる必要がなく、移動平均の値保存にLEを使用しすぎるので100Hz~1kHz程度でキャプチャするようにする。


## ボタン入力のローパスフィルタ

おそらく普通にやろうと思ったら、以下のようなコード(架空)になると思われる。入力値を保持しておいて平均値を出せば良い。

{% highlight cpp %}
queue<int> buf;
int dout;
while(true) {
	buf.enqueue(get_input());
	if (buf.size() > BUF_SIZE) {
		buf.dequeue()
	}
	dout = buf.sum() / buf.size();
}
{% endhighlight %}

論理回路で実装するなら（定石ではあるが）簡略化できる点がある。一つはtrue/falseの2値であること、もう一つはボタンの入力が安定したら平均値は最大値に張り付くはずなので平均値計算は不要である。

これを踏まえると以下のような回路を考えるのが妥当である。

<div class="mermaid">
graph LR
    Button -- bool -->BUF_0
    BUF_0 --> BUF_1
    BUF_1 --> BUF_2
    BUF_2 --> BUF_3
    BUF_0 --> assign
    BUF_1 --> assign
    BUF_2 --> assign
    BUF_3 --> assign
    assign["BUF_0 and BUF_1 and BUF_2 and BUF_3"] -- bool -->dout
</div>

クロックについては省略したが、立ち上がりが来るたびにButton->BUF_0, BUF_0->BUF_1...と代入することでBUFの長さで過去クロック分のデータを蓄積することができる。

あとは保持されている値がすべてTrueであることを確認して出力してあげれば良い。

## 実装

[UntiChatter.scala](https://github.com/kamiyaowl/chisel-practice/blob/94dd3a965d3c9fc8dd75394450032b482ac794e5/src/main/scala/bf/UntiChatter.scala)




[次回 - ChiselでBF処理系を作る(3)](https://kamiyaowl.github.io/blog/chisel-bf-3/)
